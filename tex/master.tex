% !TEX encoding = UTF-8 Unicode

\documentclass{article}

\usepackage{color}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}

\usepackage[english,serbian]{babel}
%\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{algpseudocode}

%header
\usepackage{fancyhdr}
\pagestyle{fancy}

%\newtheorem{primer}{Пример}[section] %ćirilični primer
\newtheorem{primer}{Primer}[section]
\newtheorem{defi}{Definicija}[section]
\newtheorem{teo}{Teorema}[section]


\begin{document}

\begin{titlepage} 
	\centering
	{\scshape\LARGE Matematički fakultet \par}
	\vspace{1cm}
	{\scshape Master rad\par}
	\vspace{0.5cm}
	{\huge\bfseries Detekcija kolizije u realnom vremenu\par}
	\vspace{0.5cm}
    \includegraphics[width=0.45\textwidth]{logo-matf.jpg}\par\vspace{1cm}
    Student:\hfill Mentor: \par
	{ Nikola Dimitrijević} \hfill dr Vesna Marinković
	\vfill
    
	\vfill
    
	Članovi komisije:\par
	dr Vesna Marinković \par
    dr Predrag Janičić\par
    dr Ivan Čukić
	\vfill

% Bottom of the page
	{\large Beograd, 2019. \par}
\end{titlepage}

\abstract{
Abstrakt.

\tableofcontents

\newpage

\section{Uvod}
\label{sec:uvod}
Uvod.

\section{Motivacija}
\label{sec:naslov1}
Detekcija kolizije je ključan deo svakog pogona igre (eng. {\em game engine}), a danas ga svaka velika
video igra koristi. Industrija video igara svake godine raste \cite{game_industry},
toliko da ima veći prihod od filmske i muzičke industrije zajedno! Zaista, industrija igara ima prihod od
115 milijardi dolara naspram 41 milijardi filmske i 17 milijardi muzičke industrije \cite{music} \cite{movie} \cite{game_industry}.
Posledice neispravnosti igara nisu dramaticne poput neispravnost softvera u avionskoj ili automobilskoj industriji, ali 
se svakako jasno odražavaju negativno na prihod.
Korisnici očekuju visok stepen doteranosti video igara, pa bi postojanje velikog broja bagova 
 obeshrabrilo potencijalne kupce. Na slici \ref{fig:batman} se vidi bag gde je igrač propao kroz 
 mapu, a na slici \ref{fig:horse} igrač ne može da se popne na konja pošto on lebdi u vazduhu.

Pojavljuju se na tržištu VR rukavice koje simuliraju dodir virtuelnih objekata, a za njih je 
detekcija kolizije svakako presudna. Potrebno je bar 1000 puta u sekundi pružiti povratnu informaciju
da bi simulacija dodira bila uverljiva \cite{haptic}. 

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.15]{batman.jpg}
\end{center}
\caption{Propadanje kroz mapu.}
\label{fig:batman}
\end{figure}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.35]{horse.png}
	\end{center}
	\caption{Levitirajući konj.}
	\label{fig:horse}
\end{figure}

Problem detekcije svih parova kolizije je u najgorem slučaju kvadratne složenosti i od toga se ne može pobeći,
ali uglavnom ih ima mnogo manje od gornje granice.
Razlog zahteva da se izvršava u realnom vremenu kod interaktivnih programa je očigledan, ali je takođe
potrebana mogućnost da se što češće i efikasnije utvrde kolizije. Filmovi nisu interaktivan sadržaj i zato
je učestalost osvežavanja slike od 24hz, uz korišćenje zamućivanja pokreta (eng. {\em motion blur}),
dovoljno dobro za većinu ljudi. Standard za igre na konzolama je barem 30hz, a na desktop računarima 
cilj je barem 60hz. Za VR je potrebno barem 90hz inače će lako prouzrokovati dizorijentaciju, mučninu i druge
neželjene efekte \cite{importance}.

Nema najboljeg algoritma detekcije kolizije za svaki mogući slučaj. 
Neki su dobri za uniformno raspoređene objekte u prostoru, ali loši kada su svi na jednom mestu, 
dok su drugi indiferentni što se tiče raspršenosti i više im je bitna brzina kretanja objekata.
Takođe, isti algoritam može imati značajno bolje performanse ako su njegovi parametri dobro 
izabrani za neku hardversku arhitekturu ili scenario. 
Te okolnosti su inspirisale razvoj programa koji omogućava brzo i interaktivno menjanje različitih
algoritama detekcije kolizije, postavljanje njihovih parametara kao i posmatranje performansi.


\section{Glavne karakteristike}
\label{sec:naslov2}

\subsection{Faze}
Broadphase, narrowphase, bounding box.

Celokupan zadatak detekcije kolizije se deli na dve faze: broadphase i narrowphase. 
U prvoj fazi, broadphase, odbacuje se vecina kandidata mogucih parova koji imaju koliziju, i cilj je da 
da faza bude sto efikasnija u odnosu na broj svih elemenata.
Iako postoje slučajevi, u mnogim primenama nisu svi objekti prosta geometrijska tela poput kocki, kvadara ili lopti.
Mogu biti razna kompleksna tela poput kompozicije prostijih tela, ili trijangulisana reprezentacija 
nekih objekata. Ta kompleksnija tela mogu biti sastavljena od velikog broja tih prostijih delova ili
od stotina hiljada trouglova. Tada bi bilo vrlo neefikasno i nepraktično tražiti kolizije posmatrajući
tako kompleksne strukture objekata. Mnogo je bolje da se razmatra nekakva jednostavnija reprezentacija svih 
tih objekata. Ono što se najčešće radi jeste da se naprave najmanje kutije koje će sadržati u potpunosti te objekte.
Te kutije su u obliku kvadra i svaka njegova strana je paralelna nekoj osi koordinatnog sistema. 
Umesto da se računaju preseci između velikog broja prostih objekata koji čine celinu jednog, sada se posmatraju 
samo preseci među kutijama koje sadrže sve objekte. Taj metod se naziva ograničavajuće kutije
porvnane prema osama (eng. {\em Axis Aligned Bounding Box}), odnosno AABB.

todo moguće je i sfera, orijentisan Bounding box, convex hull.

\begin{teo}
	Teorema o razdvajajućim osama. 

	Dva konveksna objekta se ne preklapaju ako postoji prava (osa) na kojoj se projekcije 
	tih objekata ne preklapaju. 
\end{teo}
Nezavisno od dimenzionalnosti, razdvajajuća osa je uvek linija. Na primer, trodimenzionalan prostor
je razdvojiv ravnima, ali razdvajajuća osa je normalna na razdvajajuću ravan.

Teorema o razdvajajućim osama daje inspiraciju za konstrukciju algoritma provere kolizije.
Dovoljno je pronaći samo jednu pravu tako da se  projekcije tela na njoj ne preklapaju.
Moguće je na primer da se uzmu normalne svih lica jednog trijangulisanog tela, izračunaju projekcije drugog 
tela na svaku pravu, i ako postoji neka prava na kojoj ne postoji presek onda uopste i nema preseka između
dva tela. Međutim to nije dovoljno dobro za potrebe detekcije kolizije u realnom vremenu. Zato se tokom 
broadphase ova teorema primenjuje samo za proveru preseka među AABB.

Teorema o razdvajajućim osama je takođe korisna za pronalaženje minimalnog vektora translacije, odnosno
vektor najmanjeg intenziteta za koji treba jedan objekat da se pomeri da bi prestalo da bude kolizije među dva objekta.
Minimalni vektor translacije je vrlo koristan prilikom razrešavanja kolizije, odnosno kada se ustanovi da
se dva objekta prekpapaju, potrebno je pomeriti ih tako da se više ne seku i promeniti im vektore brzina.
Međutim to je posao koji je odvojen od problema detekcije kolizije pa neće biti mnogo dublje razmatran.

Kada se ustanovi da postoji presek između dve AABB, to ne znači da zaista postoji presek između dva objekta
koje ti AABB enkapsuliraju. Na primer, jedan AABB može da sadrži loptu prečnika $r$, a drugi 
da sadrži objekat sagraćen od tankih ivica kocke čija je dužina ivice $r$. Tada se zaista njihove kutije 
seku, iako tela unutar njih nemaju presek.

todo slika

%https://www.scss.tcd.ie/~manzkem/CS7057/cs7057-1516-07-NarrowPhase-mm.pdf
Rešavanje problema određivanja da li postoji presek objekata unutar AABB koji su kandidati za koliziju 
se radi u narrowphase fazi. Bounding volume hierarchies, AABB tree, OBB tree.


U slučaju da su ti objekti unutar AABB neka prosta geometrijska tela poput
lopte ili kvadra, tada možemo lako primeniti teoremu o razdvajajućim osama da bismo videli da li zaista 
postoji preklapanje među njima. Međutim, krije se jedan problem.
AABB se mogu posmatrati kao projekcije tela na sve tri ose u prostoru.
Tada se dakle posmatraju samo tri prave, ne sve moguće prave. 
U slučaju prikazanom na "slici" ispod, vidi se krug i rotiran pravougaonik. Ako gledamo njihove projekcije 
na $x$ i $y$ ose onda oni prema tome imaju presek, iako posmatrajući sliku očigledno nema preseka.
Pomoću opisanog kontraprimera se vidi da posmatranjem projekcija na samo bazne ose prostora nije dovoljno
u opštem slučaju. Na slici \ref{fig:counter} prikazana su dva oblika, jedan konveksan a drugi nekonveksan. 
Za bilo koju pravu projekcija oblika na nju ima presek, iako oni u stvari nemaju presek, što predstavlja 
primer razloga zašto teorema o razdvajajućim osama zahteva konveksna objekta.

\begin{verbatim}
todo slika

\-\
 \ \
O \_\
\end{verbatim}


\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.15]{theorem_counterexample.png}
	\end{center}
	\caption{Projekcija nekonveksne površi na pravu.}
	\label{fig:counter}
\end{figure}

\subsection{Konzistentnost vremena izvršavanja}

Nekad je od interesa samo ukupno vreme potrošeno za više iteracija provere kolizije.
To svakako nije slučaj za potrebe izvršavanja u realnom vremenu. Ako samo jedna iteracija 
detekcije kolizije traje višestruko duže od ostalih onda dolazi do takozvanog "seckanja" što
kad se dešava  u prevelikoj meri dovodi do neupotrebljivog proizvoda pošto korisnicima postaje nepodnošljivo
korišćenje takvog programa.
Opisan problem je jasan i očekivano je da se to želi izbeći. 
Međutim sledi sličan problem koji nije očigledno da toliko smeta.
Ekrani imaju fiksnu učestalost osvežavanja, najčešće je 60hz, mada postaju sve više popularni 
% https://www.blurbusters.com/faq/120hz-monitors/
ekrani sa 120, 144, pa čak i 240hz učestalošću osvežavanja. Dakle ekran od 60hz će svakih 
16.67 milisekundi iscrtati sledeću sliku. Ako se između dva osvežavanja ekrana uvek pripremi
nova slika to je odlično. 
Još bolje da nova slika bude izračunata neposredno pre osvežavanja ekrana jer se onda 
prikazuje verodostojnija slika za taj trenutak. 
Svakako će uvek postojati neko kašnjenje od trenutka interakcije korisnika sa igrom ili simulacijom do
trenutka kada se prikaže slika, ali je cilj da to kašnjenje bude što manje. 
Kada se u jednom ciklusu osvežavanja ekrana pripremi više od jedne slike, onda se uzima ona koja je najnovija,
a prethodne se odbacuju. 
Dakle praktično je bačen trud uložen u pravljenje svih slika osim poslednje.
Kada nije izračunata nova slika za sledeći ciklus osvežavanja ekrana onda će opet biti prikazana slika
iz prošlog ciklusa. Tada se gubi maksimalna glatkoća slike i brzina odziva programa. 
Broj slika po sekundi (eng. {\em Frames per second}), FPS, je broj slika koje program napravi u jednoj sekundi.
Naizgled ako program ima 60FPS to je savršeno za ekran od 60hz. To ipak ne mora da bude slučaj.
U toku jedne sekunde u prvih 500 milisekundi može biti 59 slika, a u preostalih 500 milisekundi samo jedna 
nova slika. To zaista jeste 60FPS, ali ono što je prikazano na ekranu nije mnogo bolje od 2FPS,
što je prektično uvek nedopustivo loše. 
Dakle sa jedne strane nije dobar višak slika jer se nepotrebno troše resursi na njih iako se ne prikazuju, 
a sa druge strane manjak slika dovodi do neprijatnosti.
Zato je bitno da cela simulacija, a samim tim i detekcija kolizije ima što konzistentnije vreme izvršavanja.

Na slici <todo> se vidi da je program napravio 60 slika, tj. da praktično ima 60fps, iako je prikaz na ekranu 
ekvivalentan sa 30FPS, što je još jedan primer nepoželjne posledice nekonzistentnosti vremena izvršavanja. 

todo nacrtaj sliku gde su svaki parni trenutak osvežavanja ekrana sadrži dva frejma, a svaki neparni 
nijedan


\subsection{Temporalna koherencija}

Često nije cilj samo jednom odrediti kolizije za neku scenu, nego i kolizije u trenutku koji ubrzo sledi.
Objekti na sceni se u glavnom ne teleportuju nego se malo po malo kreću sa prolaskom vremena.
Tako su pozicije objekata u bliskim trenucima slični i to se može iskoristiti za dodatno ubrzanje algoritama 
detekcije kolizije. Generalno je princip da se čuvaju svi parovi kolizije i u svakoj iteraciji 
izbace oni oni koji više nisu u koliziji a dodaju oni koji su u tom trenutku došli u koliziju.
Na taj način se značajno smanjuje vreme potrebno za izračunavanje kolizija kroz iteracije.
U slučaju da se objekti jako sporo ili uopšte ne kreću algoritmi koji dobro koriste svojstvo temporalne 
koherencije će u svakoj iteraciji imati linearno vreme izvršavanja, što će posle biti dublje razmatrano. 

\subsection{Paralelizacija, memorija}

\subsection{Preciznost, preseci zapremina pokretnih tela.}

Moguće su različite preciznosti detekcije kolizije. 
Uglavnom je razlog za odabir nepreciznije opcije kraće vreme izvršavanja i manja potrošnja memorije.
Pošto se provera kolizije dešava u diskretnim vremenskim trenucima umesto kontinualno, onda je moguće da 
je između dva uzastopna trenutka bilo kolizije, iako u nijednom od njih nema kolizije. 
Ovaj fenom se naziva tuneliranje (eng. {\em. tunneling}) i prikazan je primer na slici \ref{fig:tunnel}. 

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.45]{tunnel.png}
	\end{center}
	\caption{Tuneliranje.}
	\label{fig:tunnel}
\end{figure}

Tuneliranje se češće dešava kod malih objekata, a takođe i kod 
onih koji se brzo kreću. U oba slučaja problem je u tome što je put koji objekat pređe između dve provere 
kolizija velik u odnosu na veličinu objekta. 
Problem se rešava tako što se ne proverava kolizija za sâm objekat, već za celu zapreminu kroz koju je on prošao 
od prošlog trenutka provere kolizije pa do trenutnog. Na slici \ref{fig:tunnel_fix} je obojena zapremina 
koja se dodatno proverava umesto samo zapremine objekta.



\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.45]{tunnel_fixed.png}
	\end{center}
	\caption{Sprečavanje tuneliranja.}
	\label{fig:tunnel_fix}
\end{figure}

Pod preciznošću se može smatrati i verodostojnost među grafičkim modelima i objektima koji predstavljaju njihovu koliziju.
Na slici \ref{fig:hitbox} je prikazana aproksimacija kompleksnijeg modela čoveka pomoću manjeg broja kvadara.
Na taj način se može dobiti prostiji, ali dovoljno dobar model za detekciju kolizije koji je značajno 
jeftiniji za upotrebu u realnom vremenu. 

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.45]{hitbox.png}
	\end{center}
	\caption{Reprezentacija modela čoveka.}
	\label{fig:hitbox}
\end{figure}

\subsection{Kako radi na različitim konfiguracijama}

Simulacija se izvršava u diskretnim koracima, ali je pitanje kolika je vremenska razlika između dva koraka.
Prevelika razlika između dva koraka je svakako nepoželjna jer je onda i prevelika razlika između dve slike scene.

Na primer, potrebno je objekat pomerati udesno za 10 jedinica svake sekunde. Neka je interval koraka simulacije 
$p$ jednak $0.01$ sekund, onda je dovoljno da se u svakom koraku vrednost x koordinate tog objekta ažurira na sledeći način:

\begin{primer}
\label{pr:x}

$$ x:= x + 10 * 0.01 $$
\end{primer}

Zaista, kako se svakog koraka x uveća za 0.1, a ima tačno 100 koraka u sekundi, onda će se $x$ uvećati za 10 svake sekunde.

Poželjno je da su koraci što bliže, međutim ako bi se izabrao fiksan interval koraka $p$, onda se može desiti
da se na određenoj konfiguraciji sistema program ne izvršava dovoljno brzo. 
Tada bi razlika između dva koraka bila $q$ gde je $q > p$, a u svakom koraku bi simulacija napredovala za 
$p$ jedinica unapred. Kako je $q > p$ onda bi simulacija izgledala kao usporeni snimak.

Rešenje je da se koristi razlika vremena proteklog između dva uzastopna koraka, u oznaci $dt$, (eng. {\em delta time}).
Korišćenjem $dt$ je moguće izvršavanje simulacije čije vreme teče konzistentno nezavisno od broja izvršenih koraka u 
jedinici vremena. Ako je harver bolji onda će imati više koraka, odnosno više slika u sekundi, a ako je 
sporiji onda će biti manje slika u sekundi ali neće izgledati kao da je usporen snimak.
$dt$ bi u idealnom slučaju bio inverz od fps, tj. $dt = 1/fps$, ali proteklo vreme između dve slike je promenljivo.
Može se primetiti da dodvanjam promenljivoj $x$ vrednost $dt$ svakog koraka, u stvari se vrednost $x$ povećava 
za 1 svake sekunde, jer vreme svih koraka tokom jedne sekunde mora ukupno biti baš 1.
Umesto ažuriranja kao u primeru \ref{pr:x}, sada se vrednost $x$ ažurira na sledeći način:
\begin{primer}
	\label{pr:x2}
	
	$$ x:= x + 10 * dt $$
\end{primer}

Kada se koristi $dt$ za ažuiriranje svih objekata onda se lako može simulacija ubrzati množenjem $dt$ 
sa $k$ za $k$-tostruko ubrzanje, ili deljenjem sa $k$ za $k$-tostruko usporenje. Postavljanjem $dt$ na 0 svi 
objekti postaju statični. 
Na vrlo niskim fps igre postaju neprijatne za korišćenje, ali čak mogu postati nestabilne. Dolazi do nepoželjnih efekta 
poput tuneliranja prikazanog na slici \ref{fig:tunnel}. Tada se često uzima donja gornja granica za $dt$, pa 
ako je vreme između dva koraka veće od te gornje granice onda će igra biti u usporenom snimku, što se i želelo izbeći 
ali je često bolji rezultat nego problem tuneliranja.

Pogon igara Unity deli sva ažuriranja na dve vrste: FixedUpdate i Update. 
FixedUpdate se koristi za promene sila nad objektima pošto se koraci izračunavanja fizike izvode u fiksnim intervalima, 
dok se Update koristi za operaicje koje je potrebno izvršiti pre svakog iscrtavanja slike. 
Na primer, izmene korisničkog interfejsa igre spada pod Update, a primena sile ili obrtnog momenta spada pod FixedUpdate.
Unity izvršava FixedUpdate i fiziku 50 puta u sekundi, nezavisno od broja slika u sekundi \cite{unity}.
To znači da ako se igra izvršava na 25fps onda će otprilike biti dva poziva FixedUpdate po svakoj slici,
a ako se izvršava na 100 fps tada između nekih slika neće biti nijednog poziva fizike i FixedUpdate.


\section{Neki algoritmi}
\label{sec:algoritmi}

Rezultat izvršavanja algoritma detekcije kolizije je skup svih parova koji su u koliziji.
U najgorem slučaju (na primer kada su svi objekti kocke na istoj poziciji) se svaki objekat
seče sa svim ostalim i tada ima $ {n\choose 2}  $ preseka. Međutim, taj najgori slučaj se retko dešava
u stvarnim primenama, pa postoji mnoštvo algoritama detekcije kolizije čija složenost zavisi i od broja
parova koji su u koliziji. Za takave algoritme kažemo da su izlazno-zavisni, tj.
vreme izvršavanja zavisi i od veličine izlaza. Tokom razmatranja algoritama podrazumeva se da su svi
objekti ograničavajuće kutije koje su paralelne osama, tj. AABB.
Broj kolizija među elemntima će dalje biti označen kao $R$. 

\subsection{Trivijalni algoritam}
\label{subsec:triv}

Intuitivno se može doći do trivijalnog algoritma detekcije kolizije. 
Jednostavno se svaki za element proveri da li ima presek sa svim ostalim elementima.
Algoritam je ispravan i njegova vremenska složenost je $\Theta (n^2) $, dok je prostorna složenost
$O(n^2)$, odnosno $\Theta(R)$, pošto svaki par objekata koji je u koliziji treba sačuvati.
Glavna mana ovakvog algoritma je kvadratna vremenska složenost čak i kada nema nijedne kolizije.
Bolji algoritmi rešavaju ovaj problem uglavnom particionisanjem prostora na manje potprostore, tako da
se provere kolizije vrše samo nad manjim podskupovima svih elemenata.

\begin{algorithm}
	\caption{Trivijalan algoritam detekcije kolizije}
    \label{alg:triv}
	\begin{algorithmic}[1]
		\Procedure{BasicCollision}{$elements$}\Comment{elements je niz svih objekata}
		\State $Parovi := \{ \}$
		\For{i:=0 to n-1}
			\For{j:=i+1 to n}

			\If{i-ti i j-ti elementi imaju presek}
				\State dodaj (i, j) u skup Parovi
			\EndIf		
		\EndFor
		\EndFor
		\State \textbf{return} $Parovi$
		\EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Octree}
\label{subsec:octree}

Oktri (eng. {\em Octree}) je struktura podataka koja se koristi za rekurzivno deljenje trodimenzionog
prostora na oktante. Oktri je stablo kod koga svaki unutrasnji čvor ima tačno 8 dece, odnosno oktanata. 
Svaki čvor Oktrija deli prostor na osam oktana.
Može biti tako implementiran da predstavlja i beskonačan prostor.
Na slici \ref{fig:oct} je prikazan način particionisanja.j

Objekti se ubacuju u stablo počevši od korena idući rekurzivno kroz one oktante kojima objekat pripara,
sve dok se ne stigne do lista.
Nije problem po opisanom postupku ubaciti tačku u stablo, ali se postavlja pitanje šta raditi sa objektima
koji pripadaju više oktanata.
Jedno rešenje je da se objekat ubaci u svaki oktant kome bar delimično pripada. 
Veliki problem sa tim je ako je u pitanju veliki objekat, onda će on pokriti mnoge oktante, njihove 
podoktante i tako rekurzivno. To nije velika smetnja kada su svi objekti sličnih veličina, ali ako 
nisu, onda mogu i memorijska i vremenska složenost eksplodirati. 
Moguće su male nadogradnje Oktrija da bi se taj slučaj izbegao, na primer kada se novi objekat doda 
u čvor, proveri se da li možda ceo oktant pripada tom objektu, ako je to slučaj onda svi objekti pridruženi
tom oktantu imaju koliziju i nije potrebno dalje rekurzivno particionisanje tog oktanta.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.15]{octree.png}
	\end{center}
	\caption{Rekurzivno deljenje kocke na oktante.}
	\label{fig:oct}
\end{figure}



\subsection{Sweep and prune}
\label{subsec:sap}


\subsection{BSP}
\label{subsec:bsp}


\section{Implementacija}
\label{sec:implementacija}


\section{Evaluacija}
\label{sec:evaluacija}

\section{Zaključak}
\label{sec:zakljucak}

Zaključak. 

\addcontentsline{toc}{section}{Literatura}
\appendix
\bibliography{bibl} 
\bibliographystyle{plain}

\appendix
\section{Dodatak}
Dodatak.
\end{document}
